def hex_to_bin(d):  # 16진수를 딕셔너리로 이용해서 이진수 이어붙이기
    code_map = {
        '0' : '0000' , '1' : '0001', '2' : '0010', '3' : '0011', '4' : '0100', '5' : '0101',
        '6' : '0110' , '7' : '0111', '8' : '1000', '9' : '1001',
        'A' : '1010' , 'B' : '1011', 'C' : '1100', 'D' : '1101', 'E' : '1110', 'F' : '1111'
    }
    binary_code =''     # 이진수 코드로 저장 할 변수
    for cd in d:        # 입력한 d(data) 리스트의 요소를 각각 2진수로 만들기.
        binary_code += code_map[cd]

    return binary_code  # 이진수 코드 반환

def decoder(d):
    decode_map ={
        '001101' : '0', '010011' : '1', '111011' : '2', '110001' : '3', '100011' : '4', '110111' : '5',
        '001011' : '6', '111101' : '7', '011001' : '8', '101111' : '9'
    }

    end_c = len(d) - 1  # 이진코드의 제일 끝 지점.
    while d[end_c] == '0':  # 1이 있는 지점 찾기
        end_c -= 1

    # 암호 해독문제 참고.
    decode_num = []     # 해석한 값 저장하는 리스트.
    while end_c >= 5:   # 6자리 보다 밑이면 앞쪽에 온 것.
        code = d[end_c - 5:end_c + 1]   # 6자리씩 코드 자르기.
        if code in decode_map:      # 자른 코드가 디코드_맵에 있으면 해석해서 리스트에 넣기.(문자열 형태)
            decode_num.append(decode_map[code])
            end_c -= 6  # 6자리 이동
        else:
            break  # 혹시 해독 불가능한 코드가 나오면 중단.(끝자리가 0이 나와버리면 + 해독 가능한 코드는 연속적이다)

    print(' '.join(decode_num[::-1]))   # 왜 거꾸로인가? 해석을 뒤에서부터 했으니까.


data = list(input().strip())
decoder(hex_to_bin(data))
